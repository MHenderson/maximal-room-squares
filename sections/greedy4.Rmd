---
output: html_document
editor_options: 
  chunk_output_type: console
---

In this section we keep track at every step of which pairs are
available for which empty cells. This means that every time a
new cell is filled we update all of the cells in the same
row or same column by removing any pairs that share an element
in common with the most recently assigned pair. We also update
every remaining cell by removing the pair that was most recently
assigned.

This is the slowest approach but possibly the most interesting.
Can we learn anything by looking at those lists of available
pairs as the algorithm runs?

```{r greedy4_alg}
n <- 10

tic()
R <- expand_grid(row = 1:(n - 1), col = 1:(n - 1)) %>%
  mutate(first = as.numeric(NA), second = as.numeric(NA)) %>%
  mutate(Pe = list(combn(as.numeric(0:(n - 1)), 2, simplify = FALSE))) %>%
  greedy4()
toc()
```

```{r greedy4_is_maximal_room}
# is R a maximal partial Room square?
is_maximal_proom(R)
```

```{r greedy4_plot, echo=FALSE, message=FALSE, fig.width=9, fig.height=9}
nf <- n_filled_cells(R)
v <- volume(R)

ggplot(data = R %>% pivot_wider(), aes(col, row)) +
  geom_segment(data = grid_lines(n-1, n-1), aes(x = x, y = y, xend = xend, yend = yend), size = .1) +
  geom_text(data = R %>% pivot_wider() %>% filter(!is.na(first)), aes(label = paste(first, second, sep = ","))) +
  scale_y_reverse() +
  coord_fixed() + 
  theme_void() +
  theme(
    legend.position  = "none"
  ) +
  labs(
    title = glue("A maximal partial Room square of order {n}"),
    subtitle = glue("Number of filled cells: {nf}, Volume: {v}.")
  )
```
