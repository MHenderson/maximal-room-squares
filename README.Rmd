---
output: github_document
editor_options: 
  chunk_output_type: console
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "figure/"
)

sapply(list.files("R", full.names = TRUE), source)
```

# maximal-room-squares

<!-- badges: start -->
<!-- badges: end -->

```{r R}
library(dplyr)

set.seed(55)

n <- 8

# an empty tidy room square grid
R <- expand_grid(row = 1:(n - 1), col = 1:(n - 1)) %>%
  mutate(first = as.integer(NA), second = as.integer(NA)) %>%
  pivot_longer(first:second)
```

```{r main_loop}
library(tictoc)

tic()
# go through each symbol and try to place it in a cell
# this can be the basis of is_maximal
# i.e. run through this loop once and return true iff
# no more cells are filled during the loop. i.e. the
# empty cells after are precisely the empty cells before
for(p in combn(0:(n-1), 2, simplify = FALSE)) {
  
  # try to find a hole
  x <- first_available_cell(R, p)
  
  # if we were successful then fill that hole
  if(!is.null(x))  {
    R <- update_(R, x, p)
  }
  
  csv_line <- paste(x[1], x[2], p[1], p[2], volume(R), sep = ", ")
  message(csv_line)
  
}
toc()
```

```{r verify}
is_partial_room(R)
```

```{r plot, echo=FALSE}
library(colorspace)
library(ggplot2)

ggplot(data = R %>% pivot_wider(), aes(col, row)) +
  geom_tile(aes(fill = factor(first))) +
  geom_tile(aes(fill = factor(second)), height = .5, width = .5) +
  geom_segment(data = grid_lines(n-1, n-1), aes(x = x, y = y, xend = xend, yend = yend), size = .1) +
  scale_fill_discrete_qualitative() +
  scale_y_reverse() +
  coord_fixed() + 
  theme_void() +
  theme(
    legend.position  = "none"
  )
```

