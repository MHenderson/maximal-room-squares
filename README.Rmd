---
output:
  github_document:
    toc: yes
editor_options: 
  chunk_output_type: console
references:
- id: meszkaMaximalPartialRoom2021
  abstract: >-
    A partial Room square is maximal if no further pair of elements can be
    placed into any unoccupied cell without violating the conditions that define
    a partial Room square. This article is concerned with determining the
    spectrum of volumes of maximal partial Room squares of order n where the
    volume is the number of occupied cells and the order n is even.
  accessed:
    - year: 2021
      month: 7
      day: 21
  author:
    - family: Meszka
      given: Mariusz
    - family: Rosa
      given: Alexander
  container-title: Journal of Combinatorial Designs
  DOI: 10.1002/jcd.21777
  ISSN: 1520-6610
  issue: '7'
  issued:
    - year: 2021
  language: en
  note: '_eprint: https://onlinelibrary.wiley.com/doi/pdf/10.1002/jcd.21777'
  page: 482-501
  source: Wiley Online Library
  title: Maximal partial Room squares
  type: article-journal
  URL: https://onlinelibrary.wiley.com/doi/abs/10.1002/jcd.21777
  volume: '29'
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "figure/"
)

sapply(list.files("R", full.names = TRUE), source)
```

# maximal-room-squares

<!-- badges: start -->
<!-- badges: end -->

Below we implement two greedy procedures for
building maximal partial Room squares,
inspired by
@meszkaMaximalPartialRoom2021

## I: greedy1

In this section the greedy procedure involves
visiting all cells in order and placing the
least available pair that does not violate
the conditions of being a partial Room square.

```{r greedy1_init}
library(dplyr)
library(tictoc)

# the order of Room square we are looking for
n <- 10

# a data frame representing an empty Room square
# of the desired order
R <- expand_grid(row = 1:(n - 1), col = 1:(n - 1)) %>%
  mutate(first = as.integer(NA), second = as.integer(NA)) %>%
  mutate(avail = list(0:(n - 1)))

# pairs to be used in order
P <- not_used_pairs(R)
#P <- P[order(sapply(P, diff), decreasing = TRUE)]

# empty cells to be visited in order
E <- empty_cells(R)
#E <- E[order(sapply(sapply(E, diff), abs), decreasing = TRUE)]
```

```{r greedy1_alg}
tic()
# iterate through empty cells in given order
for(e in E) {
  
  # these symbols are available
  available <- R[R$row == e[1] & R$col == e[2], "avail"]$avail[[1]]

  # iterate through un-used pairs in given order
  for(p in P) {
    
    # if empty cell e is suitable for pair p
    # then:
    # assign p to cell e,
    # remove cell e from the list of empty cells
    # remove cell p from the list of pairs
    # remove both elements of p from lists of symbols missing in row e[1]
    # remove both elements of p from lists of symbols missing in col e[2]
    # and stop
    if(p[1] %in% available && p[2] %in% available) {

      # assign p to cell e,
      R[R$row == e[1] & R$col == e[2], "first"] <- p[1]
      R[R$row == e[1] & R$col == e[2], "second"] <- p[2]

      # remove cell e from the list of empty cells
      E <- E[-match(list(e), E)]
      # remove cell p from the list of pairs
      P <- P[-match(list(p), P)]

      # remove both elements of p from lists of available symbols in row e[1]
      R[R$row == e[1], "avail"]$avail <- lapply(R[R$row == e[1], "avail"]$avail, remove_both, p)
      # remove both elements of p from lists of available symbols in col e[2]
      R[R$col == e[2], "avail"]$avail <- lapply(R[R$col == e[2], "avail"]$avail, remove_both, p)

      break()
    }
    
  }
  
}
toc()
```

```{r greedy1_is_maximal_room}
# is R a maximal partial Room square?
is_maximal_proom(R)
```

```{r greedy1_plot, echo=FALSE, message=FALSE, fig.width=9, fig.height=9}
library(ggplot2)
library(glue)

nf <- n_filled_cells(R)
v <- volume(R)

ggplot(data = R %>% pivot_wider(), aes(col, row)) +
  geom_segment(data = grid_lines(n-1, n-1), aes(x = x, y = y, xend = xend, yend = yend), size = .1) +
  geom_text(data = R %>% pivot_wider() %>% filter(!is.na(first)), aes(label = paste(first, second, sep = ","))) +
  scale_y_reverse() +
  coord_fixed() + 
  theme_void() +
  theme(
    legend.position  = "none"
  ) +
  labs(
    title = glue("A maximal partial Room square of order {n}"),
    subtitle = glue("Number of filled cells: {nf}, Volume: {v}.")
  )
```

## II: greedy2

In this section we consider a greedy procedure that considers
the pairs first and places the next pair in the first available
cell that does not violate the conditions of being a partial
Room square.

```{r greedy2_init}
# a data frame representing an empty Room square
# of the desired order
R <- expand_grid(row = 1:(n - 1), col = 1:(n - 1)) %>%
  mutate(first = as.integer(NA), second = as.integer(NA)) %>%
  mutate(avail = list(0:(n - 1)))

# pairs to be used in order
P <- not_used_pairs(R)
#P <- P[order(sapply(P, diff), decreasing = TRUE)]

# empty cells to be visited in order
E <- empty_cells(R)
#E <- E[order(sapply(sapply(E, diff), abs), decreasing = TRUE)]
```

```{r greedy2_alg}
tic()
# iterate through pairs in given order
for(p in P) {
  
  # iterate through empty cells in given order
  for(e in E) {
    
    # these symbols are available
    available <- R[R$row == e[1] & R$col == e[2], "avail"]$avail[[1]]

    # if empty cell e is suitable for pair p
    # then:
    # assign p to cell e,
    # remove cell e from the list of empty cells
    # remove cell p from the list of pairs
    # remove both elements of p from lists of symbols missing in row e[1]
    # remove both elements of p from lists of symbols missing in col e[2]
    # and stop
    if(p[1] %in% available && p[2] %in% available) {

      # assign p to cell e,
      R[R$row == e[1] & R$col == e[2], "first"] <- p[1]
      R[R$row == e[1] & R$col == e[2], "second"] <- p[2]

      # remove cell e from the list of empty cells
      E <- E[-match(list(e), E)]
      # remove cell p from the list of pairs
      P <- P[-match(list(p), P)]

      # remove both elements of p from lists of available symbols in row e[1]
      R[R$row == e[1], "avail"]$avail <- lapply(R[R$row == e[1], "avail"]$avail, remove_both, p)
      # remove both elements of p from lists of available symbols in col e[2]
      R[R$col == e[2], "avail"]$avail <- lapply(R[R$col == e[2], "avail"]$avail, remove_both, p)

      break()
    }
    
  }
  
}
toc()
```

```{r greedy_2_is_maximal_room}
# is R a maximal partial Room square?
is_maximal_proom(R)
```

```{r greedy_2_plot, echo=FALSE, message=FALSE, fig.width=9, fig.height=9}
nf <- n_filled_cells(R)
v <- volume(R)

ggplot(data = R %>% pivot_wider(), aes(col, row)) +
  geom_segment(data = grid_lines(n-1, n-1), aes(x = x, y = y, xend = xend, yend = yend), size = .1) +
  geom_text(data = R %>% pivot_wider() %>% filter(!is.na(first)), aes(label = paste(first, second, sep = ","))) +
  scale_y_reverse() +
  coord_fixed() + 
  theme_void() +
  theme(
    legend.position  = "none"
  ) +
  labs(
    title = glue("A maximal partial Room square of order {n}"),
    subtitle = glue("Number of filled cells: {nf}, Volume: {v}.")
  )
```

## III: Calculate available pairs

In this section we process cells in order but when we are considering
which pairs to place in the current cell we only consider those
pairs that are available for the current cell. We calculate the available
pairs as the intersection Pe of P (the set of all pairs so for not used)
and A (the set of combinations of size 2 from elements not already
used either in the current column or the current row).

One benefit of this approach is that we can study the sets Pe.
Below, for example, we track the sets Pe as the algorithm runs
so that afterwards we can inspect those sets.

```{r greedy3_init}
# a data frame representing an empty Room square
# of the desired order
R <- expand_grid(row = 1:(n - 1), col = 1:(n - 1)) %>%
  mutate(first = as.integer(NA), second = as.integer(NA)) %>%
  mutate(avail = list(0:(n - 1)))

# pairs to be used in order
P <- not_used_pairs(R)
#P <- sample(P, length(P))
#P <- P[order(sapply(P, diff), decreasing = TRUE)]

# empty cells to be visited in order
E <- empty_cells(R)
#E <- sample(E, length(E))
#E <- E[order(sapply(sapply(E, diff), abs), decreasing = TRUE)]
```

```{r greedy3_alg}
# log the available elements and pairs at each step
X <- tribble(~i, ~j, ~available, ~Pe)

tic()
# iterate through empty cells in given order
for(e in E) {
  
  # these symbols are available
  available <- R[R$row == e[1] & R$col == e[2], "avail"]$avail[[1]]
  
  # if there are fewer than 2 available symbols then move to the next empty cell
  if(length(available) < 2) {
    X <- X %>%
      bind_rows(
        tribble(  ~i,   ~j,      ~available, ~Pe, ~fill,
                e[1], e[2], list(available),  NA, FALSE)
      )
    next()
  }
  
  # these are the available pairs
  # this possibly doesn't work
  Pe <- intersect(P, combn(available, 2, simplify = FALSE))
  
  # if there are none then move to the next empty cell
  if(length(Pe) < 1) {
      X <- X %>%
        bind_rows(
          tribble(  ~i,   ~j,     ~available, ~Pe, ~fill,
                  e[1], e[2], list(available), NA, FALSE)
        )
    next()
  }
  
  X <- X %>%
    bind_rows(
      tribble  (~i,   ~j, ~available, ~Pe, ~fill,
              e[1], e[2],  available,  Pe,  TRUE)
      )

  # choose the first suitable pair
  p <- Pe[[1]]

  # assign p to cell e,
  R[R$row == e[1] & R$col == e[2], "first"] <- p[1]
  R[R$row == e[1] & R$col == e[2], "second"] <- p[2]

  # remove cell e from the list of empty cells
  E <- E[-match(list(e), E)]
  # remove cell p from the list of pairs
  P <- P[-match(list(p), P)]

  # remove both elements of p from lists of available symbols in row e[1]
  R[R$row == e[1], "avail"]$avail <- lapply(R[R$row == e[1], "avail"]$avail, remove_both, p)
  # remove both elements of p from lists of available symbols in col e[2]
  R[R$col == e[2], "avail"]$avail <- lapply(R[R$col == e[2], "avail"]$avail, remove_both, p)

}
toc()
```

```{r greedy3_is_maximal_room}
# is R a maximal partial Room square?
is_maximal_proom(R)
```

```{r greedy3_plot, echo=FALSE, message=FALSE, fig.width=9, fig.height=9}
nf <- n_filled_cells(R)
v <- volume(R)

ggplot(data = R %>% pivot_wider(), aes(col, row)) +
  geom_segment(data = grid_lines(n-1, n-1), aes(x = x, y = y, xend = xend, yend = yend), size = .1) +
  geom_text(data = R %>% pivot_wider() %>% filter(!is.na(first)), aes(label = paste(first, second, sep = ","))) +
  scale_y_reverse() +
  coord_fixed() + 
  theme_void() +
  theme(
    legend.position  = "none"
  ) +
  labs(
    title = glue("A maximal partial Room square of order {n}"),
    subtitle = glue("Number of filled cells: {nf}, Volume: {v}.")
  )
```

Here is a plot of the sizes of the sets Ep as the algorithm runs.

```{r X, include=FALSE}
X <- X %>%
  mutate(
    n = row_number(),
    m = map_dbl(Pe, length)
  )
```

```{r X_plot, echo=FALSE}
X %>%
  ggplot(aes(x = n, y = m, colour = fill)) +
    geom_point() +
    theme_minimal()
```

The filled cells are coloured blue and the red dots
represent empty cells. As the resulting square is maximal
we end up with a run of empty cells at the end and the
volume of the partial Room square is the number of
blue dots.

Are these plots worth investigating? Can they tell us
anything about the possible volumes of partial Room
squares?

There's nothing to prevent us from ordering the points
in descending order. Or turning the points into columns.

```{r Xplot2, echo=FALSE}
X %>%
  ggplot(aes(x = desc(reorder(n, m)), y = m, fill = fill)) +
    geom_col(width = 1, alpha = .5) +
    theme_minimal()
```

At first I wondered if a proof might be possible based
on the slope of this curve. Are there some constraints
that prevent this curve from being steep enough to reach
the bottom before 24 (the least volume for a maximal
partial Room square of order 10).

For example, the first drop in this plot has size 17
and it's easy to see why. In the first cell all pairs
are available and so the first point is at 45. In the
next cell we have to remove all 17 other pairs involving
one or other of the two symbols in the first pair because
the current cell either lies in the same row or column.

Now is it interesting to note that we never have another
drop of that height again. Is that always true? In fact
the next biggest drop looks like it's about half the
height of the first one. It seems like maybe there are
some constraints on these heights that would prevent us
reaching 0 too quickly but it's quite hard to understand
what is going on in general.

Also, I wonder if it's valid to do what I've done with
this plot. The first plot really corresponds to a sequence
of partial Room squares that arise from the greedy
procedure. But this plot doesn't have the same connection.
It's just a reordering of the first plot. Is that a problem?

Another observation is that in this example we are
moving along rows and rows will inevitably have at
least four empty cells. So the red dots we see on
the x-axis in little groups of four or five correspond
to rows. In fact, in this case we end up with an
empty last row which are the eight red dots on the
x-axis at the end.

To have positive volume requires that there are gaps
in those red dots. The volume can only happen between
gaps. Does that help? Do the gaps and the drop heights
conspire together to limit the total volume. Actually,
what we are interested in is low volume. We want to
show that a certain minimum volume is required.

```{r, include=FALSE}
P <- list(c(0, 1), c(0, 2), c(0, 3), c(0, 4), c(1, 2), c(1, 3), c(1, 5), c(2, 3), c(2, 6), c(4, 5), c(4, 6), c(4, 7), c(4, 8), c(4, 9), c(5, 6), c(5, 7), c(5, 8), c(5, 9), c(6, 7), c(6, 8), c(6, 9), c(7, 8), c(7, 9), c(8, 9))
P2 <- list(c(0, 5), c(0, 6), c(0, 7), c(0, 8), c(0, 9), c(1, 4), c(1, 6), c(1, 7), c(1, 8), c(1, 9), c(2, 4), c(2, 5), c(2, 7), c(2, 8), c(2, 9), c(3, 4), c(3, 5), c(3, 6), c(3, 7), c(3, 8), c(3, 9))

E <- list(c(1, 1), c(2, 2), c(3, 3), c(4, 4), c(3, 4), c(4, 2), c(2, 3), c(5, 5), c(4, 3), c(1, 2), c(6, 6), c(7, 7), c(8, 8), c(9, 9), c(7, 8), c(9, 6), c(6, 9), c(8, 7), c(8, 9), c(9, 7), c(1, 4), c(2, 1), c(6, 8), c(7, 6))
```

# References